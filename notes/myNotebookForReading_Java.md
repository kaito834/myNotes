This is a note for me to understand Java and related topics. This note especially focuses on references to the basics of Java.

# スッキリわかるJava入門 第2版
https://www.amazon.co.jp/dp/B00MIM1KFC (in Japanese)

## 第Ⅰ部 ようこそJavaの世界へ
### 1.3 変数宣言の文
p.49 小数を格納できる2つのデータ型(double, float), 1.3.3 データ型
> 実は、浮動小数点方式には「真に厳密な計算ができない」という弱点があります。つまり、計算を
> 行った際にわずかな誤差が発生することがあるのです。 ... そのため、誤差が許されない計算、
> 特にお金の計算に double や float を使ってはいけません。

p.50 1文字だけを格納できるchar型、文字列を格納できるString型, 1.3.3 データ型
> この例にあるように、ソースコードに「文字」データを記述する場合は引用符(')で囲みます。そ
> して「文字列」データを記述する場合は二重引用符(")を使います。このため、
> 「char gender; gender = "男";」とするとコンパイルエラーになります。

p.58 Javaの進化の歴史
- ①3度の大幅改良
- ②変化したバージョン番号の振り方

### 第2章 式と演算子
This chapter is helpful to me.

### 3.1 プログラムの流れ
p.99 構造化定理, 3.1.1 代表的な制御構文
> どんな複雑なプログラムでも、順次・分岐・繰り返しの3つの制御構造を組み合わせれば作成する
> ことが可能なことが数学的に証明されています。

### 第4章 配列
This chapter is helpful to me.

### 4.4 配列のデータをまとめて扱う
p.151 4.4.2 拡張 for 文
> 拡張for文は、配列の要素を1つずつ取り出すループを簡単に書くために導入された新しいfor文の
> 文法です。

### 5.4 オーバーロードの利用
p.194 メソッドのシグネチャ, 5.4.1 類似する複数のメソッドを定義する
> メソッド宣言で「戻り値の型」の後に記述する以下の情報をまとめて、メソッドのシグネチャ
> (signature)といいます。
> ①メソッド名 ②引数の個数・型・並び順
> オーバーロードは「シグネチャが重複しない場合のみ許される」と覚えておいてもよいでしょう。

### 5.5 引数や戻り値に配列を用いる
p.196 5.5.2 値渡しと参照渡し
> メソッドを呼び出すときに引数として変数を指定した場合、メソッドに渡されるのは変数そのもの
> ではなく、変数に入っている値です(正確には、メソッドを呼び出した時点での変数の値が、メソッ
> ドの仮引数にコピーされます)。このように、値そのものが渡される呼び出しを値渡し
> (call by value)と呼びます。

p.198 5.5.2 値渡しと参照渡し
> 今回の配列の例のように、引数としてアドレスを渡すことを参照渡し(call by reference)とい
> いますが、参照渡しを行うと「呼び出し先で加えた変更が呼び出し元にも影響する」ようになりま
> す(なお、Javaのこのしくみは、厳密には「参照の値渡し」といわれるもので、狭義の参照渡しと
> 区別することがあります)。

### 第6章 複数クラスを用いた開発
This chapter is helpful to me.

## 第Ⅱ部 すっきり納得オブジェクト指向
### 8.2 クラスの定義方法
|クラス名|名詞|単語の頭が大文字|Hero、MonsterInfo|
|フィールド名|名詞|最初以外の単語の頭が大文字|level、itemList|
|メソッド名|動詞|最初以外の単語の頭が大文字|attack、findWeakPoint|

### 9.2 コンストラクタ
p.348 9.2.1 生まれたてのインスタンスの状態
表9-1 フィールドの初期値

p.352 コンストラクタと見なされる条件, 9.2.3 コンストラクタの定義方法
- ①メソッド名がクラス名と完全に等しい
- ②メソッド宣言に戻り値が記述されていない(voidもダメ)

p.358 コンストラクタの特例, 9.2.6 暗黙のコンストラクタ
> クラスに1つもコンストラクタが定義されていない場合に限って、「引数なし、処理内容なし」
> のコンストラクタ(デフォルトコンストラクタ)の定義がコンパイル時に自動的に追加される。

p.360 別のコンストラクタの呼び出しに関するルール, 9.2.7 ほかのコンストラクタを呼び出す
> 「this.クラス名(引数);」と記述することはできない。
> その代わりに「this(引数);」と記述する。

### 9.3 静的メンバ
p.366 public static final コンビネーション, 9.3.1 クラス上に準備されるフィールド
> 多くの場合、static は final(第1章 1.3.5項)やpublic(10章で学習)と一緒に指定され、
> 「変化しない定数を各インスタンスで共有するため」に利用されます。

### 10.2 メンバに対するアクセス制御
p.384 メンバに関するアクセス修飾の定石, 10.2.4 アクセス修飾の定石
- フィールドはすべてprivate
- メソッドはすべてpublic

### 11.2 インスタンスの姿
This section is helpful for me to understand instance.

### 11.3 継承とコンストラクタ
p.429 11.3.1 継承を利用したクラスの作られ方
> 実はJavaでは、「すべてのコンストラクタは、その先頭で必ず内部インスタンス部(=親クラス)
> のコンストラクタを呼び出さなければならない」というルールになっています。

### 11.4 正しい継承、間違った継承
This section is helpful for me to understand the design of inheritance.

# JavaによるRESTfulシステム構築
https://www.oreilly.co.jp/books/9784873114675/ (in Japanese)

## 4章 HTTPメソッドとURIマッチング
### 4.2 @Path
p.50 4.2.3 マトリックスパラメータ
> マトリックスパラメータは、URI文字列のパス内に埋め込まれた名前/値のペアである。以下に例を示す。
> `http://example.cars.com/mercedes/e55;color=black/2006`
> マトリックスパラメータはURIセグメントの後に続き、その境界が「;」文字によって区切られる。

> マトリックスパラメータはURIの特定のセグメントの属性を示し、識別目的の
> ために使用されるという点で、クエリパラメータとは異なる。マトリックスパラメータを形容詞と考えても
> よい。

## 6章 JAX-RSコンテンツハンドラ
### 6.2 JAXB
p.78
> JAXBは以前からあるJava仕様であり、JAX-RSで定義されているのではない。JAXBは、Javaクラスを
> XMLおよびXMLスキーマにマッピングするアノテーションフレームワークである。

p.82 6.2.2 JAXB JAX-RSハンドラ
> JAXBアノテーションをJavaクラスに適用すると、クライアントとWebサービス間
> のXMLドキュメントの交換は非常に容易になる。組み込みのJAXBハンドラは、applicatoin/xml、
> text/xml、application/\*+xmlのメディアタイプに対してJAXBでアノテートされたクラスを処理する。

pp.86-87 6.2.4 JSONとJSONスキーマ
> JavaとJSONについてGoogleで検索してみると、JavaとJSON間のマーシャリングとアンマーシャリ
> ングを支援するフレームワークが数多く存在することに気づく。その中で特筆すべきものがJacksonフ
> レームワークだ。このフレームワークは、Java beanからJSONに、またJSONからJava beanに自動変
> 換するJAX-RSコンテンツハンドラを備えている。また、JavaオブジェクトモデルからJSONスキーマド
> キュメントの生成機能も備えている。

> 実際にはこれらの作業はすべてJacksonフレームワークのJAX-RS統合が行うため、JAX-RSクラスに関
> してあなたが行う作業は、JAX-RSメソッドを記述する際に出力と入力のフォーマットをapplication/JSON
> として指定するだけだ。
