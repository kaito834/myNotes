これは、「[実用SSH セキュアシェル徹底活用ガイド 第2版](http://www.oreilly.co.jp/books/4873112877/)」を読み、気になる記述（および関連する情報）を記録したテキストです。

# 1章　SSHへの招待
## 1.4.4 認証鍵とエージェント
p.9
> 鍵については詳しくは6章で述べるが ...
> この鍵はセキュリティ上の理由から暗号化され保存されており、
> ユーザが入力する秘密のパスフレーズで復号してから利用される。 ...
> ローカルマシン上には稼働中のssh-agentプログラムがあり、鍵を
> メモリ上に保持していることになる。

### Related Link
- [In-memory extraction of SSL private keys](http://c0decstuff.blogspot.jp/2011/01/in-memory-extraction-of-ssl-private.html)

# 2章　SSHクライアントの基本的な使い方
## 2.3.1 known host(すでに知っているホスト)
p.21
> クライアントもサーバを公開鍵暗号で認証するのだ。これがSSHの
> known host機能である。簡単に説明すると、SSHサーバはそれぞれ、
> 「ホスト鍵」と呼ばれる秘密の一意なIDを持っており、これを
> クライアントが識別する。クライアントは、最初にリモートホストに
> 接続した際に「ホスト鍵」に対応する公開鍵を受け取り、ローカル
> アカウントに保存する。 ...  
> 一度、公開鍵を保存しておけば、二度目以降の接続ではSSHクライアントは
> リモートホストのidentityをこの公開鍵でチェックするようになる。

## 2.5 SSHエージェント
pp.31-32
> ログイン状態で、SSHエージェントを走らせたまま端末から離れるのは
> 危険である。エージェントがプライベート鍵を持ったままだと、誰でも
> その鍵を使うことで、パスフレーズを知らなくともリモートのアカウントに
> 接続できてしまうし、もっとひどいと、侵入者に技術があれば、動いている
> エージェントからプライベート鍵を取り出して盗むことも可能だからだ。
> このような状態で離席しなければならない場合は、端末をスクリーンセーバ
> などでパスワードロックしたり、ssh-add -D で読み込み済みの鍵をクリア
> しておき、戻ってきたら再度鍵を読み込ませるようにする等の処置を必ず
> 行っておくべきであろう。他にも、ssh-agentを不正な利用から守るために、
> ssh-addでssh-agentに「ロック」をかけることもできる。

# 3章　インサイドSSH
## 3.3 SSHのアーキテクチャ
pp.47-48 SSH で使われる鍵の種類（表3-1 に基づく）
- 名前,有効期間,作成者,種類,目的
- ユーザ鍵,永続的,ユーザ,公開鍵,サーバに対してユーザを識別する
- ホスト鍵,永続的,管理者,公開鍵,サーバ/マシンを識別する
- セッション鍵,セッション限り,クライアント(およびサーバ),秘密鍵,通信を保護する

> セッション鍵(Session Key)
>  ...
> ランダムに生成された対象鍵であり、SSHクライアントとサーバとの間の通信を暗号化
> するために用いられる。この鍵は、盗聴されることがないようにSSH接続の確立中に
> セキュアな方法で共有される。クライアント、サーバの双方が同じセッション鍵を持ち
> 通信の暗号化に用いられる。SSHセッション終了時に、この鍵は破棄される。
>  ...
> SSH接続ではいくつかのセッション鍵が用いられる。通信の方向（サーバからクライアント、
> クライアントからサーバ）ごとに暗号化用の鍵があり、完全性チェックのためにも別の
> 鍵がある。すべてのセッション鍵は単一のシークレット（secret）から生成されるため、
> ここでは便宜上これらのセッション鍵をまとめて「セッション鍵」と呼称し、区別する
> ことが必要な場合のみ、個々のセッション鍵を明示する。

## 3.4.1 プロトコルの概要
pp.49-51 SSHプロトコル：
- SSH-TRANS (SSH Transport Layer Protocol)
  + アルゴリズムネゴシエーション
  + セッション鍵の交換
  + セッション識別子
  + サーバ認証
  + プライバシ
  + 完全性
  + データ圧縮
- SSH-AUTH  (SSH Authentication Protocol)
  + クライアント認証
    * publickey
    * hostbased
    * password
    * gssapi
    * gssapi-with-mic
    * external-keyx
    * keyboard-interactive
- SSH-CONN  (SSH Connection Protocol)
  + チャネルの多重化
    * 擬似端末
    * フロー制御
    * シグナルの伝送
    * リモートでのプログラム実行
    * 認証エージェントのフォワーディング
    * TCPポートフォワーディングとXフォワーディング
    * 端末制御
    * サブシステム
- SSH-SFTP  (SSH File Transfer Protocol)
  + リモートのファイルシステムの接続
  + ファイル転送

大まかな流れ（便宜上のもの、このように設計されているわけではない）
1. SSH-TRANS：セキュアで全二重のバイトストリームの確立
2. SSH-AUTH：サーバがクライアントを認証
3. SSH-CONN：SSH-TRANS のストリームを利用した高度サービスの提供
  + そのうちの一つに SSH-FTP がある。

p.52
> SSHプロトコルのフォーマットや手順は、SSHクライアントとサーバ間で
> やりとりされるデータについてのみ適用される。たとえば、以下にあげる
> ような事項についてはまったく言及されていない。
>
> ・鍵をディスク上に保存する際のフォーマット
> ・ユーザの認可（~/.ssh/authorized_keysなど）
> ・鍵エージェント、あるいはエージェントフォワーディング
>
> この他にも、一般的にSSHの一部として考えられている多くの事項がSSH
> プロトコルには含まれておらず、実装依存となっている。 ...
> ssh -vv が生成するデバッグメッセージを追うことで...

## 3.4.2.5 サーバ認証となりすましの対策：その実態
p.60
> 詳細な手順を以下に示す。
> 1. クライアントがチャレンジを送出する。
> 2. サーバがホスト鍵で署名したチャレンジを返却する。
> 3. クライアントは署名およびサーバと鍵の組み合わせを検証することで、サーバのidentityを検証する。
>
> それなりに理解している読者であれば、乱数によるチャレンジを用いることで、
> レスポンスが攻撃者により再生されないことや以前のセッションのリプライでない
> ことを保証すればよいと考えるかもしれない。確かに悪くないが、これでは
> うまくない。この手順では中間介入攻撃を防止することができないのだ！
> 中間介入攻撃の攻撃者はチャレンジをそのままサーバに渡し、署名した
> チャレンジを取得したうえでそれをクライアントに返却することができてしまう。
> つまり、この手順でクライアントが確認できることは接続の先に存在する
> 通信相手が実際のサーバとやりとり(talk)することができるというだけでしか
> ない。クライアントが本来確認すべきことは、その通信相手が実際のサーバで
> あることである。これを実現するため、乱数によるチャレンジを用いる代わりに、
> サーバは前述したSSHセッション識別子に署名を行う。この識別子はセッション
> ごとに一意であり、いずれの側も強制的に特定の値を設定することはできない
> ことを思い出してほしい。中間介入攻撃を行うためには、SSHプロトコルを
> クライアント側、サーバ側の両方で個別に実行する必要があるが、両方の接続で
> 用いる識別子は異なっていることが保証されているため、攻撃者はどうしようもない。
> 攻撃者がクライアントを欺くためにはサーバによって署名されたクライアント側の
> 識別子が必要であるが、取得可能なものはサーバ側の識別子のみである。サーバに
> 対して偽りの識別子に署名させるように仕向けることはできない。

## 3.5 インサイド SSH-1
pp.72-73

> サーバ鍵
>
> SSH-1 の固定鍵な鍵交換においては、ホスト鍵と区別するためにサーバ鍵と
> 呼ばれる非対称鍵が追加で用いられる。サーバ鍵は一時的な公開鍵/プライベート鍵
> のペアであり、1時間ごとに生成され、セッション鍵のforward secrecy を提供
> するために用いられるものである。
> forward secrecy は万一ユーザやホストの秘密鍵のように長期間用いられる
> シークレットが盗まれたとしても、以前に記録されたSSHセッションの復号に
> 用いることができないという状態を意味する。決してディスクに書き込まれない
> 追加の鍵により、これが担保される。SSH-2におけるすべての鍵交換の基礎となる
> Diffie-Hellman アルゴリズムはそれ自体がforward secrecyを有しており、
> 追加の「サーバ鍵」は不要である。

## 3.9.2 名前解決サービスのなりすましとIPスプーフィング
pp.96-98
> SSHはサーバホストのidentityを暗号により検証することでこの攻撃に対抗する。
> セッションを確立する際に、SSHクライアントはサーバ名と対応する鍵の対から
> なるリストを用いて、サーバのホスト鍵を検証する。提供されたホスト鍵が
> リストのいずれともマッチしなかった場合、SSHは警告を表示する。 ...
> SSH-2プロトコルでは、鍵にPKI証明書を含めることもできる。

## 3.9.4 中間介入攻撃（man-in-the-middle attack）
> SSHは2つの方法でこの攻撃に対抗する。1つはサーバのホスト認証である。サーバに
> 侵入していないかぎり、攻撃者はサーバのホスト鍵のプライベート鍵を取得できず、
> サーバになりすますことができない。この対策を有効にするうえでは、クライアントが
> サーバから提供された公開鍵をknown hostsリストと照合して確認することが肝要であり、
> さもなくばサーバが本物であることが保証できない。このため新しいサーバに初めて
> 接続した際にsshがホスト鍵を受け入れる時点では、中間介入攻撃を防ぐことはできないが、
> この時点でなりすましが行われていないことが保証できるのであれば、これ以降この
> サーバへの接続は、サーバのホスト鍵が盗まれないかぎりセキュアである。
> SSHが提供するもう1つの対抗策はユーザの認証方式によるものである。パスワード
> 方式は明らかに脆弱であるが、公開鍵方式やホストベースの認証は中間介入攻撃にも
> 対抗できる。鍵交換を参照しているだけでセッション鍵が暴露されることはないため、
> 攻撃者はそれぞれの側で個別に鍵交換を行い、クライアントおよびサーバの双方から
> 鍵を取得するといった能動的な攻撃を行うことを余儀なくされる。もっとも、
> SSH-1とSSH-2いずれの鍵交換も、それぞれの側のセッション鍵が異なるように
> 設計されている。さらに公開鍵、もしくはホストベースの認証を行う際に、クライアント
> から提示される電子署名には署名されたデータの中にセッション識別子が含まれている。
> このため、攻撃者はクライアントから提供された認証子をサーバに提示することが
> できない。またクライアントに対して別のセッション識別子に署名させることを
> 強制することもできない。
> サーバの名前と鍵の対応を検証しないかぎり、攻撃者が誰かになりすましてサーバ側に
> ログインすることができない場合でも、中間介入攻撃を実行できる。もっとも、そういった
> 環境では、おそらく攻撃者は自身のアカウントや、別のクラックしたアカウントでログイン
> することもできるだろう。ある程度のスキルがあれば、攻撃者は長期間にわたって攻撃を
> 続け、被害が発生するかもしれない。

## 4.2.2.1 GnuPG を用いて検査する。
p.113
```
$ gpg --keyserver keyserver --search-keys openssh
$ gpg --verify openssh-3.9p1.tar.gz.sig openssh-3.9p1.tar.gz
```

## 6.2.1.1 OpenSSH の鍵を作る
p.248
> シェルのコマンドラインで、ssh-keygenの-Nや-Pオプションのようなパスフレーズを
> 指定するオプションを使用する前には、そのセキュリティ上の意味について注意深く
> 考えること。パスフレーズがスクリーンに表示されるせいで覗かれる可能性があるし、
> 実行中にpsコマンドで他のユーザがマシンのプロセスリストを見てしまうかもしれない。
> 加えて、シェルが打ち込んだコマンドの履歴を作成する場合には、パスフレーズは
> 第三者による読み取りが可能な履歴ファイルに書き込まれてしまう。
>
> パスフレーズを打ち込む必要をなくしたい場合には、ssh-agent、ホストベースの
> 認証あるいはKerberos認証を使用するのが正しい。

p.256 OpenSSH におけるスマートカードのサポート

## 6.3.4.1 アクセス制御
pp.270-272
> エージェントは同一のホスト上の他のプロセスとのみ通信するため、ホストの既存の
> セキュリティ機構を使用する。
>   - ファイルのアクセス権
>   - クライアントの識別子
>   - 保護メモリ
>   - 使用時のプロンプト
>  ...
> クライアントの識別子
> 一部のUnixには、名前付きパイプのある一方に存在するプロセスが、もう一方に存在する
> プロセスについて、相手側のプロセスID、ユーザIDなどを知ることができるという特色が
> ある。この機能が利用できる場合には、エージェントはクライアントのユーザIDが自身の
> ものと一致することを検証できる。
>
> 保護メモリ
> ssh-agentのプロセスがエージェントのプロトコルを通じて鍵を漏えいすることはないに
> しても、その鍵はメモリ上には存在している。権限のあるユーザがエージェントのプロセスに
> 接続し、通常のプロセス分離を迂回して、そのメモリ空間から鍵を読み出すということも
> あるだろう。一部のUnixでは、この種の外部からの干渉を制限したり防止したりできるため、
> 一部のエージェントではこの機能を使用している。

## 6.3.4.2 エージェントに対するハッキング
> 一晩といった長時間にわたってコンピュータの前を離れる場合には、できれば鍵をエージェント
> からアンロード（ssh-agent -D）するべきなのである。 ...
> - ユーザのプライベート鍵ファイルを盗み出し、パスフレーズの推測を試みる。
> - ユーザが実行しているプロセスを追跡し、パスフレーズを打ち込んでいる間にそれを
>   とらえる。
> - トロイの木馬攻撃。改変したログインプログラムやシェル、あるいはSSH実装そのもの
>   といったシステムプログラムをインストールし、ユーザのパスフレーズを盗み取る。
> - エージェントを実行しているメモリ空間のコピーを取得し、鍵を直接取り出す
>   （これは他の手段よりも若干困難である）
>
> 結論はこうだ。エージェントは信頼できるマシン上でのみ実行すること。SSHは、システムの
> 他の側面をセキュアにすることを免除してくれるものではない。

## 8.2.3 強制コマンド
p.352-

### Related Link
- https://twitter.com/kaito834/status/468007019052417024
